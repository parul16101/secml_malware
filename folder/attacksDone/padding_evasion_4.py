import os
import sys
import numpy as np
from secml.array import CArray
from secml_malware.models.malconv import MalConv
from secml_malware.models.c_classifier_end2end_malware import CClassifierEnd2EndMalware, End2EndModel
from secml_malware.attack.whitebox.c_discretized_bytes_evasion import CDiscreteBytesEvasion
from secml_malware.models import CClassifierEnd2EndMalware


class CPaddingEvasion:
    def __init__(self):
        self.net = MalConv()
        self.net = CClassifierEnd2EndMalware(self.net)
        self.net.load_pretrained_model()
        self.padding_attack = CDiscreteBytesEvasion(
            end2end_model = self.net,
            index_to_perturb=[],
            #how_many = 100,
            iterations = 100,
            is_debug = False,
            random_init = False,
            threshold = 0,
            penalty_regularizer = 0
        )

    def _run(self, x0, y0, x_init=None):
        invalid_value = 256 if self.invalid_pos == -1 else self.invalid_pos
        padding_positions = x0.find(x0 == invalid_value)
        if not padding_positions:
            self.indexes_to_perturb = []
        else:
            self.indexes_to_perturb = list(
                range(
                    padding_positions[0],
                    min(x0.size, padding_positions[0] + self.how_many_padding_bytes),
                )
            )
        return super(CPaddingEvasion, self)._run(x0, y0, x_init=x_init)

    def generate_attack(self, file_path):
        try:
            X = []
            y = []
            file_names = []

            with open(file_path, "rb") as file_handle:
                code = file_handle.read()
            x = End2EndModel.bytes_to_numpy(code, self.net.get_input_max_length(), 256, False)
            _, confidence = self.net.predict(CArray(x), True)

            X.append(x)
            conf = confidence[1][0].item()
            y.append([1 - conf, conf])
            file_names.append(file_path)

            for sample, label in zip(X, y):
                y_pred, adv_score, adv_ds, f_obj = self.padding_attack.run(CArray(sample), CArray(label[1]))
                #print(self.padding_attack.confidences_)
                #print(f_obj)

            adv_x = adv_ds.X[0, :]
            real_adv_x = self.padding_attack.create_real_sample_from_adv(file_names[0], adv_x)
            print(len(real_adv_x))
            real_x = End2EndModel.bytes_to_numpy(real_adv_x, self.net.get_input_max_length(), 256, False)
            _, confidence = self.net.predict(CArray(real_x), True)
            print(confidence[0, 1].item())

            output_file_path = "output/output_cpaddingEvasion.exe"  # Replace with the desired output file path
            with open(output_file_path, "wb") as file_handle:
                file_handle.write(real_adv_x)

            print("Modified file saved successfully.")
        except Exception as e:
            print("Attack failed. Error:", str(e))

cpadding_evasion = CPaddingEvasion()
cpadding_evasion.generate_attack(sys.argv[1])
